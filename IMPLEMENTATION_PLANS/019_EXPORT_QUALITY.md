# Plan 019: Export Quality Improvements

## Status: COMPLETE

## Problem Statement

The export pipeline has three distinct quality issues:

1. **Infographic export degrades quality**: Infographics are 2560x1440 raster images wrapped in HTML. Exporting as PDF/PPTX double-downscales via Playwright rendering and loses quality. Only PNG makes sense.
2. **PDF page breaking**: Playwright's Chromium print-to-PDF splits sections, cards, and headings mid-page. Generated HTML contains no `@media print` CSS rules.
3. **PPTX output is poor**: 4:3 aspect ratio (squarish), bland white slides with no visual formatting, text clipping, and poor content splitting. The Claude prompt is too generic.

## Architecture

The export pipeline flows: Frontend → `POST /api/sessions/{sid}/documents/{docId}/export/{format}` → `export_service.export_document()` → format-specific exporter → bytes response.

Three exporters exist:
- **PDF**: `playwright_exporter.export_pdf()` — Playwright renders HTML at 1920x1080 viewport, then `page.pdf()` with A4/0.5" margins
- **PNG**: `playwright_exporter.export_png()` — Playwright screenshots at 1920x1080 viewport
- **PPTX**: `pptx_exporter.PPTXExporter.export()` — Claude generates python-pptx code in sandbox

---

## Phase 1: PDF Page Break Fix

**Scope**: 1 file, ~40 lines. Smallest change, immediate impact.

### Problem Detail
Playwright's Chromium print engine does zero-intelligence page breaking. It doesn't avoid breaking inside `<section>`, cards (divs with border-radius/box-shadow), or after headings. The HTML generated by Gemini 2.5 Pro never includes `@media print` rules.

### Implementation

#### File: `backend/app/services/exporters/playwright_exporter.py`

**Add** a module-level constant and helper function:

```python
_PRINT_CSS = """\
@media print {
  section, article, blockquote, figure, table, ul, ol, dl,
  details, fieldset, pre {
    break-inside: avoid;
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    break-after: avoid;
    page-break-after: avoid;
  }
  h1 + *, h2 + *, h3 + * {
    break-before: avoid;
  }
  div[style*="border-radius"], div[style*="box-shadow"] {
    break-inside: avoid;
    page-break-inside: avoid;
  }
  p { orphans: 3; widows: 3; }
  img { max-height: 90vh; }
}"""


def _inject_print_css(html: str) -> str:
    """Inject print-friendly CSS before </head> for better page breaking.

    Only affects @media print — no visual change to screen rendering.
    Returns html unchanged if </head> is not found.
    """
    tag = "</head>"
    if tag not in html:
        return html
    return html.replace(tag, f"<style>{_PRINT_CSS}</style>\n{tag}", 1)
```

**Modify** `export_pdf()` — add one line before `_render_page()`:

```python
async def export_pdf(html_content: str, options: ExportOptions) -> ExportResult:
    _validate_html(html_content)
    html_content = _inject_print_css(html_content)  # <-- ADD THIS LINE
    page = None
    try:
        page = await _render_page(html_content, 1920, 1080)
        # ... rest unchanged
```

**Important**: Only inject for PDF, NOT for PNG export (PNG doesn't use print media queries).

### Tests to Add

In a new or existing test file for the playwright exporter:

```python
def test_inject_print_css_inserts_before_head():
    html = '<!DOCTYPE html><html><head><title>Test</title></head><body></body></html>'
    result = _inject_print_css(html)
    assert '@media print' in result
    assert result.index('@media print') < result.index('</head>')

def test_inject_print_css_no_head_tag():
    html = '<html><body>no head</body></html>'
    result = _inject_print_css(html)
    assert result == html  # unchanged

def test_inject_print_css_includes_break_rules():
    html = '<html><head></head><body></body></html>'
    result = _inject_print_css(html)
    assert 'break-inside: avoid' in result
    assert 'break-after: avoid' in result
    assert 'orphans: 3' in result
```

---

## Phase 2: Infographic PNG-Only Export

**Scope**: 5 backend files + 2 frontend files.

### 2a. Centralize Infographic Detection

Currently `_is_infographic_doc()` is a private function in `backend/app/api/chat.py` (lines 52-71). It needs to be reusable by the export pipeline.

#### File: `backend/app/utils/html_validator.py`

**Add** at module level (alongside existing `validate_edit_result`):

```python
import re

# Regex to match base64 image data URIs (100+ chars of base64 payload)
_BASE64_IMAGE_RE = re.compile(
    r'data:image/[^;]+;base64,[A-Za-z0-9+/=]{100,}'
)


def is_infographic_html(html: str) -> bool:
    """Detect infographic wrapper docs (minimal HTML with single base64 <img>).

    Infographic documents have a distinctive structure created by
    wrap_infographic_html(): <600 chars of HTML after removing base64
    payloads, with a single <img> tag and no structural content tags
    (<main>, <header>, <section>).

    Regular docs with embedded images are excluded by the structural
    tag check.
    """
    stripped = _BASE64_IMAGE_RE.sub("", html)
    if len(stripped) >= 600:
        return False
    if "<img" not in html or "data:image" not in html:
        return False
    lower = html.lower()
    if "<main" in lower or "<header" in lower or "<section" in lower:
        return False
    return True
```

#### File: `backend/app/api/chat.py`

**Replace** the local `_is_infographic_doc` function with an import:

```python
from app.utils.html_validator import is_infographic_html

# Remove the _is_infographic_doc function definition (lines 52-71)
# Replace all references to _is_infographic_doc with is_infographic_html
```

Search for all usages of `_is_infographic_doc` in chat.py and replace with `is_infographic_html`. The `_BASE64_RE` and `_strip_base64_for_context` remain in chat.py (they serve different purposes — context stripping for LLM calls).

### 2b. Direct Image Extraction for Infographic PNG

#### File: `backend/app/services/exporters/playwright_exporter.py`

**Add** a new export function (no Playwright dependency):

```python
import base64
import re

# Regex to extract image format and base64 payload from data URI
_DATA_URI_IMAGE_RE = re.compile(
    r'data:image/([a-zA-Z0-9+.-]+);base64,([A-Za-z0-9+/=]+)'
)


async def export_infographic_png(
    html_content: str, options: ExportOptions
) -> ExportResult:
    """Export infographic by extracting raw image bytes from base64 HTML.

    No Playwright rendering — direct base64 decode preserves full
    original resolution (typically 2560x1440).
    """
    match = _DATA_URI_IMAGE_RE.search(html_content)
    if not match:
        raise ExportError("No embedded image found in infographic HTML")

    image_format = match.group(1).lower()  # "png", "jpeg", etc.
    b64_data = match.group(2)

    try:
        image_bytes = base64.b64decode(b64_data)
    except Exception as e:
        raise ExportGenerationError(f"Failed to decode infographic image: {e}") from e

    # Normalize format for content type and extension
    ext = "jpg" if image_format == "jpeg" else image_format
    content_type = f"image/{image_format}"

    return ExportResult(
        content=image_bytes,
        content_type=content_type,
        file_extension=ext,
        filename=_generate_filename(options.document_title, ext),
        metadata={
            "size_bytes": len(image_bytes),
            "source": "direct-base64-extraction",
            "original_format": image_format,
        },
    )
```

### 2c. Infographic Detection + PNG Bypass in Export Service

#### File: `backend/app/services/export_service.py`

Read the current file to understand the `export_document()` flow. Modify it to detect infographics and handle them specially.

**Add** infographic handling inside `export_document()`:

```python
from app.utils.html_validator import is_infographic_html

async def export_document(
    document_id: str,
    format_key: str,
    version: int | None = None,
    options: ExportOptions | None = None,
) -> ExportResult:
    # ... existing HTML retrieval code ...

    # Infographic detection: restrict to PNG/HTML only
    if is_infographic_html(html_content):
        if format_key not in ("png", "html"):
            raise ExportError(
                "Infographic documents can only be exported as PNG or HTML"
            )
        if format_key == "png":
            from app.services.exporters.playwright_exporter import export_infographic_png
            return await export_infographic_png(html_content, opts)

    # ... existing exporter dispatch code (unchanged for non-infographic) ...
```

### 2d. Frontend: Hide PDF/PPTX for Infographics

#### File: `frontend/src/components/Export/ExportDropdown.tsx`

**Add** `isInfographic` prop:

```tsx
interface ExportDropdownProps {
  onExportHtml: () => void;
  disabled?: boolean;
  documentId: string | null;
  documentTitle?: string;
  isInfographic?: boolean;  // <-- ADD
}
```

**Conditionally render** PPTX and PDF buttons:

```tsx
{!isInfographic && (
  <button
    className="export-dropdown-item"
    onClick={() => handleExport('pptx')}
    disabled={!documentId || loadingFormat === 'pptx'}
  >
    {loadingFormat === 'pptx' ? (
      <span className="export-loading">Exporting...</span>
    ) : (
      'PowerPoint'
    )}
  </button>
)}
{!isInfographic && (
  <button
    className="export-dropdown-item"
    onClick={() => handleExport('pdf')}
    disabled={!documentId || loadingFormat === 'pdf'}
  >
    {loadingFormat === 'pdf' ? (
      <span className="export-loading">Exporting...</span>
    ) : (
      'PDF'
    )}
  </button>
)}
```

#### File: `frontend/src/App.tsx`

**Compute** `isInfographic` from `currentHtml`:

```tsx
import { useMemo } from 'react';

// Inside the component, after currentHtml is available:
const isInfographic = useMemo(() => {
  if (!currentHtml) return false;
  const stripped = currentHtml.replace(
    /data:image\/[^;]+;base64,[A-Za-z0-9+/=]{100,}/g, ''
  );
  return stripped.length < 600
    && currentHtml.includes('data:image')
    && !/<(main|header|section)/i.test(currentHtml);
}, [currentHtml]);
```

**Pass** to ExportDropdown:

```tsx
<ExportDropdown
  onExportHtml={handleExport}
  disabled={!currentHtml}
  documentId={activeDocumentId}
  documentTitle={documentTitle}
  isInfographic={isInfographic}  // <-- ADD
/>
```

### Tests to Add

```python
# test_html_validator.py (or extend existing)
from app.utils.html_validator import is_infographic_html

INFOGRAPHIC_HTML = (
    '<!DOCTYPE html><html lang="en"><head><meta charset="utf-8">'
    '<style>*{margin:0}body{background:#0a0a0f;display:flex;'
    'justify-content:center;align-items:center;min-height:100vh}'
    'img{max-width:100%;height:auto}</style></head>'
    '<body><img src="data:image/png;base64,' + 'A' * 200 + '" alt="test"/></body></html>'
)

REGULAR_HTML = (
    '<!DOCTYPE html><html><head><title>Doc</title></head><body>'
    '<header><h1>Title</h1></header><main><section><p>Content</p></section></main></body></html>'
)

def test_is_infographic_html_true():
    assert is_infographic_html(INFOGRAPHIC_HTML) is True

def test_is_infographic_html_false_for_regular():
    assert is_infographic_html(REGULAR_HTML) is False

def test_is_infographic_html_false_for_no_image():
    assert is_infographic_html('<html><head></head><body>Hello</body></html>') is False


# test_playwright_exporter.py (or extend existing)
import base64
import pytest
from app.services.exporters.playwright_exporter import export_infographic_png
from app.services.exporters.base import ExportOptions, ExportError

@pytest.mark.asyncio
async def test_export_infographic_png_extracts_bytes():
    test_bytes = b'\x89PNG\r\n\x1a\n' + b'\x00' * 100
    b64 = base64.b64encode(test_bytes).decode()
    html = f'<html><body><img src="data:image/png;base64,{b64}" alt="test"/></body></html>'
    result = await export_infographic_png(html, ExportOptions())
    assert result.content == test_bytes
    assert result.content_type == 'image/png'
    assert result.file_extension == 'png'

@pytest.mark.asyncio
async def test_export_infographic_png_no_image():
    html = '<html><body>No image here</body></html>'
    with pytest.raises(ExportError, match="No embedded image"):
        await export_infographic_png(html, ExportOptions())
```

---

## Phase 3: PPTX Quality Improvement

**Scope**: 3 backend files. Prompt rewrite is the bulk of the work.

### 3a. Default to 16:9 Widescreen

#### File: `backend/app/services/exporters/base.py`

**Change** `slide_width` in `ExportOptions` dataclass:

```python
# Before:
slide_width: int = 10
slide_height: float = 7.5

# After:
slide_width: float = 13.333  # 16:9 widescreen (was 10 for 4:3)
slide_height: float = 7.5
```

#### File: `backend/app/api/export.py`

**Update** the query parameter:

```python
# Before:
slide_width: int = Query(10, description="Slide width in inches"),

# After:
slide_width: float = Query(13.333, description="Slide width in inches (13.333 for 16:9)"),
```

### 3b. Strip Base64 Before Sending to Claude

#### File: `backend/app/services/exporters/pptx_exporter.py`

**Add** module-level regex (at top, near other constants):

```python
import re

_BASE64_RE = re.compile(r'(data:image/[^;]+;base64,)[A-Za-z0-9+/=]{100,}')
```

**Modify** `_build_generation_prompt()` to strip before including in prompt:

```python
def _build_generation_prompt(
    self, html_content: str, options: ExportOptions
) -> str:
    # Strip base64 images to save tokens and reduce noise
    clean_html = _BASE64_RE.sub(r'\1[IMAGE_DATA_REMOVED]', html_content)
    return f"""...(prompt using clean_html instead of html_content)..."""
```

### 3c. Rewrite the PPTX Generation Prompt

#### File: `backend/app/services/exporters/pptx_exporter.py`

**Replace** the entire `_build_generation_prompt()` method body. The new prompt:

```python
def _build_generation_prompt(
    self, html_content: str, options: ExportOptions
) -> str:
    # Strip base64 images to save tokens and reduce noise
    clean_html = _BASE64_RE.sub(r'\1[IMAGE_DATA_REMOVED]', html_content)

    return f"""Analyze this HTML document and generate Python code using python-pptx to create a professional PowerPoint presentation.

HTML DOCUMENT:
```html
{clean_html}
```

SLIDE DIMENSIONS:
- Width: {options.slide_width} inches, Height: {options.slide_height} inches
- Set via: prs.slide_width = Inches({options.slide_width}); prs.slide_height = Inches({options.slide_height})

COLOR EXTRACTION (CRITICAL):
- Extract the primary, secondary, and accent colors from the HTML's <style> block, CSS variables, or inline styles.
- Use these EXACT colors as RGBColor values throughout the presentation.
- If colors are in hex (e.g., #0D7377), convert: RGBColor(0x0D, 0x73, 0x77).
- Do NOT default to plain black text on white slides — match the document's color palette.

SLIDE STRUCTURE RULES:
1. Slide 1 = Title slide: document's h1 as title, first subtitle/description text below.
2. Each h2 heading starts a NEW slide. Never put two h2 sections on one slide.
3. Maximum 5 bullet points per slide. If more content exists, split into continuation slides titled "Section Name (1/2)", "(2/2)".
4. Maximum ~10 words per bullet point. Summarize if the HTML text is longer.
5. Tables get their own slide. Render as a python-pptx Table shape.

VISUAL FORMATTING (MANDATORY):
- Title bar: Add a filled rectangle shape (MSO_SHAPE.RECTANGLE) across the top 1.2 inches of each slide, filled with the primary color. Place the slide title as white text ON this bar.
- Body text: 16-18pt Calibri, dark color from the palette, 1.15 line spacing.
- Sub-headings within slides: bold, accent color, 20pt.
- Card-like groups: If the HTML uses cards or boxed sections, create rounded rectangle shapes (MSO_SHAPE.ROUNDED_RECTANGLE) with a light fill (10% opacity of accent) behind the text.
- Accent line: Add a thin horizontal line shape below the title bar using the accent color.
- Content margins: All text content starts at 0.7 inches from left/right edges, 1.5 inches from top (below title bar).

FONT SIZES:
- Slide title (on title bar): 28-32pt, bold, white
- Body text: 16-18pt
- Bullet sub-text: 14pt
- NEVER use fonts smaller than 14pt

IMPORTS TO USE:
```python
from pptx import Presentation
from pptx.util import Inches, Pt, Emu
from pptx.dml.color import RGBColor
from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
from pptx.enum.shapes import MSO_SHAPE
from io import BytesIO
```

DO NOT:
- Cram excessive text onto slides — split instead
- Use fonts smaller than 14pt
- Leave text running to slide edges (maintain 0.7" margins)
- Use default blank layouts with unstyled text — add visual shapes
- Import modules other than: pptx, io, base64, typing, math, collections

OUTPUT: Return ONLY executable Python code ending with:
```
output = BytesIO()
prs.save(output)
result = output.getvalue()
```"""
```

### Tests to Add

```python
# test_pptx_exporter.py (extend existing)

def test_base64_stripped_from_prompt():
    exporter = PPTXExporter(mock_provider)
    html = '<html><body><img src="data:image/png;base64,' + 'A' * 500 + '"/></body></html>'
    prompt = exporter._build_generation_prompt(html, ExportOptions())
    assert 'AAAA' not in prompt
    assert '[IMAGE_DATA_REMOVED]' in prompt

def test_default_slide_dimensions_16_9():
    opts = ExportOptions()
    assert opts.slide_width == 13.333
    assert opts.slide_height == 7.5
```

---

## Files Modified Summary

| File | Phase | Change |
|------|-------|--------|
| `backend/app/utils/html_validator.py` | 2 | Add `is_infographic_html()`, `_BASE64_IMAGE_RE` constant |
| `backend/app/api/chat.py` | 2 | Import `is_infographic_html` from validator, remove local `_is_infographic_doc` |
| `backend/app/services/exporters/playwright_exporter.py` | 1, 2 | Add `_inject_print_css()`, `_PRINT_CSS` constant, `export_infographic_png()` |
| `backend/app/services/export_service.py` | 2 | Infographic detection + PNG bypass in `export_document()` |
| `backend/app/api/export.py` | 3 | Update `slide_width` default to `13.333`, type to `float` |
| `backend/app/services/exporters/base.py` | 3 | `slide_width` default `10` → `13.333`, type `int` → `float` |
| `backend/app/services/exporters/pptx_exporter.py` | 3 | `_BASE64_RE`, base64 stripping in prompt, rewritten prompt |
| `frontend/src/App.tsx` | 2 | Compute `isInfographic` from `currentHtml`, pass to `ExportDropdown` |
| `frontend/src/components/Export/ExportDropdown.tsx` | 2 | Add `isInfographic` prop, hide PDF/PPTX when true |

## Existing Code to Reuse

| Utility | Location | How Reused |
|---------|----------|------------|
| `_is_infographic_doc()` | `backend/app/api/chat.py:52-71` | Logic extracted to `html_validator.py` |
| `_BASE64_RE` pattern | `backend/app/api/chat.py:37-39` | Same regex pattern in `html_validator.py` and `pptx_exporter.py` |
| `_generate_filename()` | `backend/app/services/exporters/playwright_exporter.py:22-30` | Used by `export_infographic_png()` |
| `ExportOptions` dataclass | `backend/app/services/exporters/base.py` | Modified defaults |
| `ExportResult`, `ExportError`, `ExportGenerationError` | `backend/app/services/exporters/base.py` | Used by `export_infographic_png()` |

---

## Verification

### Automated Tests
```bash
cd backend && pytest  # All 290+ tests pass
```

New tests to write:
1. `is_infographic_html()` — true for infographic, false for regular HTML, false for no image
2. `export_infographic_png()` — extracts correct bytes, raises on no image
3. `_inject_print_css()` — injects before `</head>`, no-op without `</head>`, includes break rules
4. PPTX base64 stripping — `[IMAGE_DATA_REMOVED]` replaces base64 in prompt
5. PPTX 16:9 — `ExportOptions()` defaults to `slide_width=13.333`
6. Infographic format guard — PDF/PPTX export of infographic raises `ExportError`

### Linting
```bash
cd backend && ruff check . && mypy .
cd frontend && npm run lint && npm run build
```

### Manual E2E
1. Create regular HTML doc → Export PDF → Verify sections/cards don't split mid-page
2. Create regular HTML doc → Export PPTX → Verify 16:9, colored title bars, formatted slides
3. Create infographic → Verify Export dropdown shows only PNG + HTML
4. Create infographic → Export PNG → Verify full resolution (file size matches original image)
5. Hit `POST /api/.../export/pdf` for infographic → Verify 400 response
6. Deploy to `clhtml.zyroi.com` → Repeat tests

---

## Implementation Order
1. **Phase 1** — PDF print CSS injection (1 file, ~40 lines, zero risk)
2. **Phase 2** — Infographic PNG-only (5 backend + 2 frontend files)
3. **Phase 3** — PPTX improvements (3 backend files, prompt is bulk of work)
